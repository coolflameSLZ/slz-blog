---
title: 'innodb存储实现'
toc: true
categories:
  - 数据库
  - mysql
tags:
  - innodb
hide: false
date: 2021-07-30 22:15:07
sortn: 10
---



本章主要介绍 innodb 引擎的存储实现

<!-- more -->

------



## mysql innodb 存储磁盘存储结构



innodb 的存储结构分为 5 级：**表空间、段、簇、页、行。**



###  簇（B+树，聚簇索引）

![img](https://cdn.jsdelivr.net/gh/coolflameSLZ/img/img20210731010412.png)

- 整个树有序，结构类似于跳表。
- 分为非叶子节点、叶子节点
- 非叶子节点，存主键+下一级指针。叶子节点存主键+数据
- 行是有序的，根据主键排序，所以支持2分查找
- 数据有冗余，有未分配空间，有已删除空间。所以数据主键要保递增，减少碎片化。



### 页(Page)



<img src="https://cdn.jsdelivr.net/gh/coolflameSLZ/img/img20210730224756.png" alt="image-20210730224756023" style="zoom:40%;" />



- 默认1页为16kb
- 页头，本页基本信息
- 虚记录，本页最小主键，本页最大主键。
- 【行】记录堆，行记录存储区，分为有效记录和已删除记录
- 未分配空间，页中未使用的空间
- 页尾，占8字节，主键存页面的校验信息



## mysql innodb 内存管理



todo







## mysql innodb 事务实现原理



### 事务特性：

- A（atomicity 原子性）：全部成功，全部失败。不允许中间状态
- I （isolation 隔离性）：并行事务不干扰
- D（Durability 持久性）：提交事务后，数据不能丢
- C（consistency 一致性）：凑数的



### 并发问题：

- 脏读（dirty read）： 读取到其他事务，没有提交的数据
- 不可重复读（non-repeatable read）：查询同一条数据两次，有可能结果不一样
- 幻读（phantom read）：select 出来的结果，可能是不存在的。<br>被其他事务插入后又删了，但中间存在期间，本事务恰好扫描到他了



### 隔离级别：

- Read Uncommitted（读取未提交内容）: 最低隔离级别，会读取到其他事务未提交的数据，

  出现的问题：**脏读**

- Read Committed（读取提交内容）: 事务过程中可以读取到其他事务已提交的数据，

  出现的问：**不可重复读**

- Repeatable Read（可重复读）: 每次读取相同结果集，不管其他事务是否提交，

  出现的问题：**幻读**

- Serializable （串行化）: 事务排队，隔离级别最高，性能最差;

  出现的问题：**性能差**

- 总结：

  1. 一般使用 RR （可重复读），但写事务的时候，尽量避免 select 范围修改。<br>如果有范围修改，则思考一下，有没有可能出现幻读，如果出现了是否有影响。
  2. 对于innodb，mvcc 并没有完全解决幻读问题。



## innodb - mvcc



### 两种查询模式

- 当前读：永远查询某一行数据的最新的版本
- 读快照：假设当前事务为A，根据事务A的 trx id（事务id）总能查到，A事务开启的那一刻， <br>数据的历史版本快照。这个快照是永远不会发生改变的。



### 可见性逻辑

- trx id 指的是事务id，是一个自增的序列。id 大，证明事务发生的时间靠后
- innodb 维护一个事务活跃列表，即 select * from information_schema.INNODB_TRX 查出来的数据。
- 可见性逻辑：
  1. 事务开始的那一刻，查询所有当前事务。tmp_trx = [当前所有事务id]
  2. tmp_trx_max = [时间轴最靠后的事务]，tmp_trx_min = [时间轴最靠前的事务]
  3. 搜索出来的数据，需要满足2个条件其中之一即可。
     - 事务id，比tmp_trx_min 的id要小（查出来的记录，在事务创建之前，就提交了）
     - 不在事务活跃列表里面。（这个事务跑得快，已经先一步提交）
  4. 如果不满足，则通过历史版本指针，找到该行数据的历史快照，正常使用即可



## mysql 锁实现原理



### **需要加锁的语句**

select for update 、update、delete ，其他语句不用加锁。



### **分析锁的几个重要前提**

- 索引：唯一索引 、 非唯一索引
- 事务隔离级别：RC 、 RR



### **根据颗粒度划分**

- 行级，锁1行

  - RC下，唯一索引，非唯一索引，使用该级别锁。

    RR下，唯一索引，使用该级别

  - 作用在索引上

  - 聚簇索引 & 二级索引

    

- 间隙，锁一部分

  - RR下，唯一索引，才使用这个锁类型

  - 索引是有序的，新的记录插入，只能插入到GAP区间内；<br>GAP锁，是计算出两条记录之间的GAP；<br>一旦锁住这个GAP。就封住了新纪录插入的可能性；<br>就能保证2次当前读返回的数据是一致的。

  - GAP锁的问题：查询where条件没有索引的时候，没法加GAP锁，很容易锁升级为表锁。

    

- 表级，锁1个表

  - **没有命中索引的时候，有概率锁表，概率还不小。**
  - 所以，事务中，加锁的语句中的where条件一定要加索引。
  - 一般来说，分两个步骤实现修改
    1. 范围查询，返回主键id
    2. 根据主键id list 进行 update。

  

### **根据类型划分**

- 共享锁
  - 读锁，可以被多个事务获取，阻止其他事务对记录的修改
- 排他锁
  - 写锁，只能被1个事务获取，只允许获得锁的事务修改数据
